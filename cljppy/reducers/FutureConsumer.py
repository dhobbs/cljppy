import atexit
from multiprocessing import *


class FutureConsumer(object):
    def __init__(self, f, *vals):
        # Only one of cancelled and realised should ever be
        # True. Really wish i could make these read only.
        self.realised = False
        self.cancelled = False

        def f_star(work_q, result_q):
            v = work_q.get()

            while not v == "POISON_PILL_CLJPPY":
                result_q.put(f(v))
                v = work_q.get()
            result_q.put("POISON_PILL_CLJPPY")

        self.__work_queue = Queue()
        self.__result_queue = Queue()
        self.__process = Process(target=f_star, args=[self.__work_queue, self.__result_queue])
        self.__process.start()
        self.values = []
        atexit.register(self.cancel)

        self.__work_queue.putMany(vals)

    def __call__(self):
        return self.deref()

    def __del__(self):
        self._finalise()

    def put(self, val):
        """
        Adds a value to the consumer's work queue
        """
        self.__work_queue.put(val)

    def putMany(self, vals):
        """
        Adds values to the consumer's work queue
        """
        self.__work_queue.putMany(vals)

    def poison(self):
        """
        Delivers the poison pill to the future
        """
        self.__work_queue.put("POISON_PILL_CLJPPY")

    def get(self):
        """
        Block until the next result is generated by the consumer.
        If the consumer has been poisoned, returns a seq of all
        values this consumer has generated.
        """
        if self.cancelled:
            return None

        if self.realised:
            return self.values

        v = self.__result_queue.get()

        if v == "POISON_PILL_CLJPPY":
            self.realised = True
            self._finalise()

        self.values.append(v)
        return v

    def cancel(self):
        if not self.realised:
            self._finalise()
            self.cancelled = True

    def _finalise(self):
        self.__work_queue.close()
        self.__result_queue.close()
        self.__process.join()
        self.__process.terminate()