import atexit
from multiprocessing import *


class FutureConsumer(object):
    def __init__(self, f, *vals):
        # Only one of cancelled and realised should ever be
        # True. Really wish i could make these read only.
        self.realised = False
        self.cancelled = False

        def f_star(connection):
            v = connection.recv()

            while not v == "POISON_PILL_CLJPPY":
                connection.send(f(v))
                v = connection.recv()
            connection.send("POISON_PILL_CLJPPY")

        self.__pipe = Pipe()
        self.__process = Process(target=f_star, args=[self.__pipe[0]])
        self.__process.start()
        self.values = []
        atexit.register(self.cancel)

        for val in vals:
            self.__pipe[1].send(val)

    def __call__(self):
        return self.deref()

    def __del__(self):
        self._finalise()

    def put(self, val):
        """
        Adds a value to the consumer's work queue
        """
        self.__pipe[1].send(val)

    def putMany(self, vals):
        """
        Adds values to the consumer's work queue
        """
        for val in vals:
            self.__pipe[1].send(val)

    def poison(self):
        """
        Delivers the poison pill to the future
        """
        self.__pipe[1].send("POISON_PILL_CLJPPY")

    def get(self):
        """
        Block until the next result is generated by the consumer.
        If the consumer has been poisoned, returns a seq of all
        values this consumer has generated.
        """
        if self.cancelled:
            return None

        if self.realised:
            return self.values

        v = self.__pipe[1].recv()

        if v == "POISON_PILL_CLJPPY":
            self.realised = True
            self._finalise()

        self.values.append(v)
        return v

    def cancel(self):
        if not self.realised:
            self.poison()
            self._finalise()
            self.cancelled = True

    def _finalise(self):
        self.__pipe[0].close()
        self.__pipe[1].close()
        self.__process.join()
        self.__process.terminate()